/* -*- c++ -*- */
/*
 * Copyright 2018 Karl Semich <0xloem@gmail.com>
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "dev_manager.h"

#include <gnuradio/io_signature.h>

#include "source_iface.h"

/*
 * Create a new instance of dev_manager and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
dev_manager_sptr
make_dev_manager ( gr::hier_block2_sptr outer )
{
  return gnuradio::get_initial_sptr( new dev_manager ( outer ) );
}

/*
 * The private constructor
 */
dev_manager::dev_manager ( gr::hier_block2_sptr outer )
  : gr::block ( "dev_manager",
      gr::io_signature::make(0, 0, 0),
      gr::io_signature::make(0, 0, 0) ),
    _outer(outer),
    _channels(0),
    _sample_rate(NAN)
{
  message_port_register_in( osmosdr::CMD_PORT );
  set_msg_handler( osmosdr::CMD_PORT, boost::bind(&dev_manager::msg_handler_command, this, _1) );
}

int dev_manager::general_work( int noutput_items,
                               gr_vector_int &ninput_items,
                               gr_vector_const_void_star &input_items,
                               gr_vector_void_star &output_items)
{
  return 0;
}

void dev_manager::add_device( gr::basic_block_sptr block, common_iface *iface )
{
  if ( iface == nullptr || block.get() == nullptr ) {
    if ( iface != nullptr || block.get() != nullptr )
      throw std::runtime_error("Either iface or block are NULL.");
    return;
  }

  size_t mboard = get_num_mboards();
  _devs.push_back( { iface, block, _channels } );

  if ( is_sink( mboard ) ) {
    // sink block
    for (size_t i = 0; i < iface->get_num_channels(); i++) {
      _outer->connect( _outer->self(), _channels, block, i );
      _chandevs.push_back( mboard );
      _channels++;
    }
  } else {
    // source block
    for (size_t i = 0; i < iface->get_num_channels(); i++) {
#ifdef HAVE_IQBALANCE
      // add iqbalance blocks if enabled
      gr::iqbalance::optimize_c::sptr iq_opt = gr::iqbalance::optimize_c::make( 0 );
      gr::iqbalance::fix_cc::sptr     iq_fix = gr::iqbalance::fix_cc::make();

      connect( block, i, iq_fix, 0 );
      connect( block, i, iq_opt, 0 );
      msg_connect( iq_opt, "iqbal_corr", iq_fix, "iqbal_corr" );

      _iq_opt.push_back( iq_opt.get() );
      _iq_fix.push_back( iq_fix.get() );

      _outer->connect( iq_fix, 0, _outer->self(), _channels );
 #else
      _outer->connect( block, i, _outer->self(), _channels );
 #endif
      _chandevs.push_back( mboard );
      _channels++;
    }
  }
}

size_t dev_manager::get_num_mboards() const
{
  return _devs.size();
}

size_t dev_manager::get_mboard_for_channel( size_t chan ) const
{
  return _chandevs.at(chan);
}

bool dev_manager::is_sink( size_t mboard ) const
{
  return get_block(mboard)->input_signature()->max_streams() > 0;
}

gr::basic_block_sptr dev_manager::get_block( size_t mboard ) const
{
  return _devs.at(mboard).block;
}

common_iface * dev_manager::get_iface( size_t mboard ) const
{
  return _devs.at(mboard).dev;
}

size_t dev_manager::get_mboard_channel( size_t mboard ) const
{
  return _devs.at(mboard).chan;
}

void dev_manager::msg_handler_command( pmt::pmt_t msg )
{
  if ( !pmt::is_dict(msg) ) {
    GR_LOG_ERROR( d_logger, boost::format("Command message is neither dict nor pair: %s") % msg );
    return;
  }

  // if pair, this throws and converts to dict
  try {
    pmt::pmt_t keys = pmt::dict_keys(msg);
  } catch ( const pmt::wrong_type & ) {
    GR_LOG_DEBUG( d_debug_logger, boost::format("Converting pair to dict: %s") % msg );
    msg = pmt::dict_add( pmt::make_dict(), pmt::car(msg), pmt::cdr(msg) );
  }

  // read chan. defaults to -1, all chans at once
  int chan;
  try {
    chan = int(pmt::to_long(
          pmt::dict_ref(
            msg, osmosdr::CMD_CHAN_KEY,
            pmt::from_long(-1)
          )
    ));
  } catch ( const pmt::wrong_type & ) {
    GR_LOG_ALERT( d_logger, boost::format("Invalid channel number %s") % pmt::dict_ref( msg, osmosdr::CMD_CHAN_KEY ) );
    return;
  }
  
  // rate applies to all channels
  pmt::pmt_t rate = pmt::dict_ref( msg, osmosdr::CMD_RATE_KEY, pmt::PMT_NIL );
  if ( rate != pmt::PMT_NIL ) {
    if ( !pmt::is_real(rate) && !pmt::is_integer(rate) ) {
      GR_LOG_ALERT( d_logger, boost::format("Invalid type for sample rate %s") % rate );
      return;
    }
    set_sample_rate( pmt::to_double(rate) );
    msg = pmt::dict_delete( msg, osmosdr::CMD_RATE_KEY );
  }

  // extract commands
  pmt::pmt_t msg_items = pmt::dict_items(msg);

  // check every device
  for (size_t mboard = 0; mboard < get_num_mboards(); mboard++) {
    int cur_chan = get_mboard_channel( mboard );
    int next_chan = cur_chan + get_iface( mboard )->get_num_channels();
    if ( chan != -1 && chan >= next_chan )
      continue;

    // if device accepts command messages, just pass it along
    gr::basic_block_sptr block = get_block( mboard );
    if ( block->has_msg_port(osmosdr::CMD_PORT) ) {
      if ( chan != -1 )
        block->_post( osmosdr::CMD_PORT, pmt::dict_add(msg, osmosdr::CMD_CHAN_KEY, pmt::from_long(chan - cur_chan)) );
      else
        block->_post( osmosdr::CMD_PORT, msg );
      continue;
    }

    int start_chan, end_chan;
    if ( chan == -1 ) {
      start_chan = cur_chan;
      end_chan = next_chan;
    } else {
      start_chan = chan;
      end_chan = chan + 1;
    }

    for (int it_chan = start_chan; it_chan < end_chan; ++ it_chan){
      // execute every command
      
      for (size_t i = 0; i < pmt::length(msg_items); ++ i){
        pmt::pmt_t const & item = pmt::nth(i, msg_items);
        try {
          exec_msg_cmd( pmt::car(item), pmt::cdr(item), it_chan );
        } catch (const pmt::wrong_type &) {
          try {
            GR_LOG_ALERT( d_logger, boost::format("Invalid command value for key %s: %s") % pmt::car(item) % pmt::cdr(item) );
          } catch (const pmt::wrong_type &) {
            GR_LOG_ALERT( d_logger, boost::format("Command is not a pair: %s") % item );
          }
          return;
        }
      }
    }
  }
}

void dev_manager::exec_msg_cmd( const pmt::pmt_t & cmd, const pmt::pmt_t & val, size_t chan )
{
  if ( cmd == osmosdr::CMD_FREQ_KEY ) {
    set_center_freq( pmt::to_double(val), chan );
  } else if ( cmd == osmosdr::CMD_GAIN_KEY ) {
    set_gain( pmt::to_double(val), chan );
  } else if ( cmd == osmosdr::CMD_RATE_KEY ) {
    // already set in msg_handler_command
    ;
  } else if ( cmd == osmosdr::CMD_ANTENNA_KEY ) {
    set_antenna( pmt::symbol_to_string(val), chan );
  } else if ( cmd == osmosdr::CMD_BANDWIDTH_KEY ) {
    set_bandwidth( pmt::to_double(val), chan );
  }
  // unfamiliar commands are ignored
}

size_t dev_manager::get_num_channels()
{
  return _channels;
}

bool dev_manager::seek( long seek_point, int whence, size_t chan )
{
  if ( chan > get_num_channels() )
    return false;

  size_t mboard = get_mboard_for_channel( chan );
  if ( is_sink( mboard ) )
    return false;

  size_t dev_chan = chan - get_mboard_channel( mboard );
  source_iface * dev = static_cast< source_iface * >( get_iface( mboard ) );

  return dev->seek( seek_point, whence, dev_chan );
}

#define NO_DEVICES_MSG  "FATAL: No device(s) available to work with."

osmosdr::meta_range_t dev_manager::get_sample_rates()
{
  if ( get_num_mboards() )
    return get_iface(0)->get_sample_rates(); // assume same devices used in the group
#if 0
  else
    throw std::runtime_error(NO_DEVICES_MSG);
#endif
  return osmosdr::meta_range_t();
}

double dev_manager::set_sample_rate( double rate )
{
  double sample_rate = 0;

  if (_sample_rate != rate) {
#if 0
    if (!get_num_mboards())
      throw std::runtime_error(NO_DEVICES_MSG);
#endif
    for (size_t mboard = 0; mboard < get_num_mboards(); mboard++) {
      common_iface *dev = get_iface( mboard );
      sample_rate = dev->set_sample_rate(rate);
      if ( !is_sink( mboard ) ) {
#ifdef HAVE_IQBALANCE
        // source block, update iqbalance if enabled
        size_t channel = get_mboard_channel( mboard );
        size_t end = channel + dev->get_num_channels();
        for (; channel < end; channel++) {
          if ( channel < _iq_opt.size() ) {
            gr::iqbalance::optimize_c *opt = _iq_opt[channel];

            if ( opt->period() > 0 ) { /* optimize is enabled */
              opt->set_period( dev->get_sample_rate() / 5 );
              opt_reset();
            }
          }
        }
#endif
      }
    }

    _sample_rate = sample_rate;
  }

  return sample_rate;
}

double dev_manager::get_sample_rate()
{
  double sample_rate = 0;

  if (get_num_mboards())
    sample_rate = get_iface(0)->get_sample_rate(); // assume same devices used in the group
#if 0
  else
    throw std::runtime_error(NO_DEVICES_MSG);
#endif
  return sample_rate;
}

osmosdr::freq_range_t dev_manager::get_freq_range( size_t chan )
{
  if ( chan > get_num_channels() )
    return osmosdr::freq_range_t();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_freq_range( dev_chan );
}

double dev_manager::set_center_freq( double freq, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _center_freq[ chan ] != freq ) {
    _center_freq[ chan ] = freq;
    return dev->set_center_freq( freq, dev_chan  );
  } else { return _center_freq[ chan ]; }
}

double dev_manager::get_center_freq( size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_center_freq( dev_chan );
}

double dev_manager::set_freq_corr( double ppm, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _freq_corr[ chan ] != ppm ) {
    _freq_corr[ chan ] = ppm;
    return dev->set_freq_corr( ppm, dev_chan );
  } else { return _freq_corr[ chan ]; }
}

double dev_manager::get_freq_corr( size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_freq_corr( dev_chan );
}

std::vector<std::string> dev_manager::get_gain_names( size_t chan )
{
  if ( chan > get_num_channels() )
    return std::vector< std::string >();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain_names( dev_chan );
}

osmosdr::gain_range_t dev_manager::get_gain_range( size_t chan )
{
  if ( chan > get_num_channels() )
    return osmosdr::gain_range_t();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain_range( dev_chan );
}

osmosdr::gain_range_t dev_manager::get_gain_range( const std::string & name, size_t chan )
{
  if ( chan > get_num_channels() )
    return osmosdr::gain_range_t();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain_range( name, dev_chan );
}

bool dev_manager::set_gain_mode( bool automatic, size_t chan )
{
  if ( chan > get_num_channels() )
    return false;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _gain_mode[ chan ] != automatic ) {
    _gain_mode[ chan ] = automatic;
    bool mode = dev->set_gain_mode( automatic, dev_chan );
    if (!automatic) // reapply gain value when switched to manual mode
      dev->set_gain( _gain[ chan ], dev_chan );
    return mode;
  } else { return _gain_mode[ chan ]; }
}

bool dev_manager::get_gain_mode( size_t chan )
{
  if ( chan > get_num_channels() )
    return false;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain_mode( dev_chan );
}

double dev_manager::set_gain( double gain, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _gain[ chan ] != gain ) {
    _gain[ chan ] = gain;
    return dev->set_gain( gain, dev_chan );
  } else { return _gain[ chan ]; }
}

double dev_manager::set_gain( double gain, const std::string & name, size_t chan)
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->set_gain( gain, name, dev_chan );
}

double dev_manager::get_gain( size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain( dev_chan );
}

double dev_manager::get_gain( const std::string & name, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_gain( name, dev_chan );
}

double dev_manager::set_if_gain( double gain, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _if_gain[ chan ] != gain ) {
    _if_gain[ chan ] = gain;
    return dev->set_if_gain( gain, dev_chan );
  } else { return _if_gain[ chan ]; }
}

double dev_manager::set_bb_gain( double gain, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _bb_gain[ chan ] != gain ) {
    _bb_gain[ chan ] = gain;
    return dev->set_bb_gain( gain, dev_chan );
  } else { return _bb_gain[ chan ]; }
}

std::vector< std::string > dev_manager::get_antennas( size_t chan )
{
  if ( chan > get_num_channels() )
    return std::vector< std::string >();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_antennas( dev_chan );
}

std::string dev_manager::set_antenna( const std::string & antenna, size_t chan )
{
  if ( chan > get_num_channels() )
    return "";

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _antenna[ chan ] != antenna ) {
    _antenna[ chan ] = antenna;
    return dev->set_antenna( antenna, dev_chan );
  } else { return _antenna[ chan ]; }
}

std::string dev_manager::get_antenna( size_t chan )
{
  if ( chan > get_num_channels() )
    return "";

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_antenna( dev_chan );
}

void dev_manager::set_dc_offset_mode( int mode, size_t chan )
{
  if ( chan > get_num_channels() )
    return;

  size_t mboard = get_mboard_for_channel( chan );
  if ( is_sink( mboard ) )
    return;

  size_t dev_chan = chan - get_mboard_channel( mboard );
  source_iface * dev = static_cast< source_iface * >( get_iface( mboard ) );

  dev->set_dc_offset_mode( mode, dev_chan );
}

void dev_manager::set_dc_offset( const std::complex<double> &offset, size_t chan )
{
  if ( chan > get_num_channels() )
    return;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  dev->set_dc_offset( offset, dev_chan );
}

void dev_manager::set_iq_balance_mode( int mode, size_t chan )
{
  if ( chan > get_num_channels() )
    return;

  size_t mboard = get_mboard_for_channel( chan );
  if ( is_sink( mboard ) )
    return;

  size_t dev_chan = chan - get_mboard_channel( mboard );
  source_iface * dev = static_cast< source_iface * >( get_iface( mboard ) );

#ifdef HAVE_IQBALANCE
  if ( chan < _iq_opt.size() && chan < _iq_fix.size() ) {
    gr::iqbalance::optimize_c *opt = _iq_opt[chan];
    gr::iqbalance::fix_cc *fix = _iq_fix[chan];

    if ( IQBalanceOff == mode  ) {
      opt->set_period( 0 );
      /* store current values in order to be able to restore them later */
      _vals[ chan ] = std::pair< float, float >( fix->mag(), fix->phase() );
      fix->set_mag( 0.0f );
      fix->set_phase( 0.0f );
    } else if ( IQBalanceManual == mode ) {
      if ( opt->period() == 0 ) { /* transition from Off to Manual */
        /* restore previous values */
        std::pair< float, float > val = _vals[ chan ];
        fix->set_mag( val.first );
        fix->set_phase( val.second );
      }
      opt->set_period( 0 );
    } else if ( IQBalanceAutomatic == mode ) {
      opt->set_period( dev->get_sample_rate() / 5 );
      opt->reset();
    }
  }
#else
  return dev->set_iq_balance_mode( mode, dev_chan );
#endif

}

void dev_manager::set_iq_balance( const std::complex<double> &balance, size_t chan )
{
  if ( chan > get_num_channels() )
    return;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

#ifdef HAVE_IQBALANCE
  if ( ! is_sink( mboard ) ) {
    // source block, update iqbalance if enabled
    if ( chan < _iq_opt.size() && chan < _iq_fix.size() ) {
      gr::iqbalance::optimize_c *opt = _iq_opt[chan];
      gr::iqbalance::fix_cc *fix = _iq_fix[chan];

      if ( opt->period() == 0 ) { /* automatic optimization desabled */
        fix->set_mag( balance.real() );
        fix->set_phase( balance.imag() );
      }
    }
  } else {
    dev->set_iq_balance( balance, dev_chan );
  }
#else
  dev->set_iq_balance( balance, dev_chan );
#endif
}

double dev_manager::set_bandwidth( double bandwidth, size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  if ( _bandwidth[ chan ] != bandwidth || 0.0f == bandwidth ) {
    _bandwidth[ chan ] = bandwidth;
    return dev->set_bandwidth( bandwidth, dev_chan );
  } else { return _bandwidth[ chan ]; }
}

double dev_manager::get_bandwidth( size_t chan )
{
  if ( chan > get_num_channels() )
    return 0;

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_bandwidth( dev_chan );
}

osmosdr::freq_range_t dev_manager::get_bandwidth_range( size_t chan )
{
  if ( chan > get_num_channels() )
    return osmosdr::freq_range_t();

  size_t mboard = get_mboard_for_channel( chan );
  common_iface *dev = get_iface( mboard );
  size_t dev_chan = chan - get_mboard_channel( mboard );

  return dev->get_bandwidth_range( dev_chan );
}

void dev_manager::set_time_source( const std::string &source, const size_t mboard )
{
  if ( mboard != osmosdr::ALL_MBOARDS ) {
      get_iface( mboard )->set_time_source( source );
      return;
  }

  for (size_t m = 0; m < get_num_mboards(); m++) { /* propagate ALL_MBOARDS */
      get_iface(m)->set_time_source( source, osmosdr::ALL_MBOARDS );
  }
}

std::string dev_manager::get_time_source( const size_t mboard )
{
  return get_iface( mboard )->get_time_source( mboard );
}

std::vector<std::string> dev_manager::get_time_sources( const size_t mboard )
{
  return get_iface( mboard )->get_time_sources( mboard );
}

void dev_manager::set_clock_source( const std::string &source, const size_t mboard )
{
  if (mboard != osmosdr::ALL_MBOARDS){
      get_iface( mboard )->set_clock_source( source );
      return;
  }

  for (size_t m = 0; m < get_num_mboards(); m++){ /* propagate ALL_MBOARDS */
      get_iface(m)->set_clock_source( source, osmosdr::ALL_MBOARDS );
  }
}

std::string dev_manager::get_clock_source( const size_t mboard )
{
  return get_iface( mboard )->get_clock_source( mboard );
}

std::vector<std::string> dev_manager::get_clock_sources( const size_t mboard )
{
  return get_iface( mboard )->get_clock_sources( mboard );
}

double dev_manager::get_clock_rate( size_t mboard )
{
  return get_iface( mboard )->get_clock_rate( mboard );
}

void dev_manager::set_clock_rate( double rate, size_t mboard )
{
  if ( mboard != osmosdr::ALL_MBOARDS ) {
      get_iface( mboard )->set_clock_rate( rate );
      return;
  }

  for (size_t m = 0; m < get_num_mboards(); m++) { /* propagate ALL_MBOARDS */
      get_iface(m)->set_clock_rate( rate, osmosdr::ALL_MBOARDS );
  }
}

osmosdr::time_spec_t dev_manager::get_time_now( size_t mboard )
{
  return get_iface( mboard )->get_time_now( mboard );
}

osmosdr::time_spec_t dev_manager::get_time_last_pps( size_t mboard )
{
  return get_iface( mboard )->get_time_last_pps( mboard );
}

void dev_manager::set_time_now( const osmosdr::time_spec_t &time_spec, size_t mboard )
{
  if ( mboard != osmosdr::ALL_MBOARDS ) {
      get_iface( mboard )->set_time_now( time_spec );
      return;
   }

  for (size_t m = 0; m < get_num_mboards(); m++) { /* propagate ALL_MBOARDS */
      get_iface(m)->set_time_now( time_spec, osmosdr::ALL_MBOARDS );
  }
}

void dev_manager::set_time_next_pps( const osmosdr::time_spec_t &time_spec )
{
  for (size_t i = 0; i < get_num_mboards(); i++) {
    get_iface(i)->set_time_next_pps( time_spec );
  }
}

void dev_manager::set_time_unknown_pps( const osmosdr::time_spec_t &time_spec )
{
  for (size_t i = 0; i < get_num_mboards(); i++) {
    get_iface(i)->set_time_unknown_pps( time_spec );
  }
}
